#### Java 集合 Set/List

- ![java集合](../images/java集合.png)
- ArrayList
- LinkedList

#### Map

- HashMap

  HashMap 是基于哈希表的 map 接口的非同步实现
  简单说就是数组+链表构成
  在 HashMap 初始化的时候会初始化一个 Entry[]数组，用来存储 key、value 对，当需要存储一个 Entry 对象，会经过 hash 算法来确定数组中的位置，产生冲突后，从头部插入当前 entry 对象，原有 Entry 链串接其后。

  HashMap 允许 null 值 null 键，键具有唯一性，所以允许一个 null 键，而值就无所谓了。相比较 HashTable，HashTable 不允许 null 值 null 键，null 值与 null 键都会抛出 NullPointException。

  HashMap 的初始容量为 16，之后以当前容量的 2 倍进行扩充。其容量始终为 2 的 n 次幂，目的是为了提高 hash 算法确定位置时的效率，通常得到 hashcode 会对当前容量进行取模运算得到散列表中存储位置，而除法运算相对效率较低，容量设置为 2 的 n 次幂便可以通过位运算快速得到模，具体位运算为 hash 与 当前容量-1 进行与运算。
  而 HashTable 的初始容量为 11，之后的扩容变为原来的 2N+1,取模运算哪儿运用除法，效率低。

  HashMap 实现了 Iterable，HashTable 实现了 Iterable 与 Enumration(历史遗留问题)

  HashMap 不保证存储顺序，LinkedHashMap 保证存储顺序，其内部实现了双向链表以保证顺序

  HashMap 是线程不安全的，如果要线程安全，可以选择 HashTable、collections.synchronizedHashMap()包装或 concurrentHashMap,推荐 concurrentHashMap。因为内部实现为分段加锁，效率较高。

  构造函数
  HashMap()
  HashMap(int capacity)
  HashMap(int capacity, float loadFactory)
  HashMap(Map<? extends K, ?extends V> map)
  继承自 abstractMap 类，实现 Map 接口

  hash()
  在 get、put 计算下标时，先对 hashCode 进行 hash 操作，然后再通过 hash 值进一步操作.

  > 高 16bit 和低 16bit 异或了一下。设计者还解释到因为现在大多数的 hashCode 的分布已经很不错了，就算是发生了碰撞也用 O(logn)的 tree 去做了。仅仅异或一下，既减少了系统的开销，也不会造成因为高位没有参与下标的计算(table 长度比较小)时，引起的碰撞。

        ```
        static final int hash(Object key) {
            int h;
            return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
        }
        ```

  indexFor(int h, int length)
  目前的 table 长度 n 为 2 的次幂，所以计算下标的时候，可使用按位与&代替取模%：

        ```
        return h & (length-1);
        ```

  get()
  获取 key 对应的 value
  传入参数 key
  通过 key 的 hash 码计算出数组中的位置
  判断是否有值，有的话进行遍历(链表)
  判断值返回

        ```
        public V get(Object key) {
            if (key == null)
                return getForNullKey();

            int hash = hash(key);

            for (Entry<K,V> e = table[indexFor(hash, table.length)];
                e != null;
                e = e.next) {
                Object k;
                if (e.hash == hash && ((k = e.key) == key || key.equals(k)))
                    return e.value;
            }
            return null;
        }
        ```

  java8 中链表长度大于 8 时，则转化为红黑树存储

        ```
        public V get(Object key) {
            Node<K,V> e;
            return (e = getNode(hash(key), key)) == null ? null : e.value;
        }

        final Node<K,V> getNode(int hash, Object key) {
            Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
            // table不为空 && table长度大于0 && table索引位置(根据hash值计算出)不为空
            if ((tab = table) != null && (n = tab.length) > 0 &&
                (first = tab[(n - 1) & hash]) != null) {
                if (first.hash == hash && // always check first node
                    ((k = first.key) == key || (key != null && key.equals(k))))
                    return first;	// first的key等于传入的key则返回first对象
                if ((e = first.next) != null) { // 向下遍历
                    if (first instanceof TreeNode)  // 判断是否为TreeNode
                        // 如果是红黑树节点，则调用红黑树的查找目标节点方法getTreeNode
                        return ((TreeNode<K,V>)first).getTreeNode(hash, key);
                    // 走到这代表节点为链表节点
                    do { // 向下遍历链表, 直至找到节点的key和传入的key相等时,返回该节点
                        if (e.hash == hash &&
                            ((k = e.key) == key || (key != null && key.equals(k))))
                            return e;
                    } while ((e = e.next) != null);
                }
            }
            return null;    // 找不到符合的返回空
        }
        ```

  put()
  校验 table 是否为空或者 length 为 0，是的话则调用 resize 进行初始化
  通过**hash 值计算索引位置**，将该索引位置的头节点赋值给 p 节点，如果该索引位置节点为空则使用传入的参数新增一个节点并放在该索引位置
  判断 p 节点的 key 和 hash 值是否跟传入的相等，如果相等, 则 p 节点即为要查找的目标节点，将 p 节点赋值给 e 节点
  如果 p 节点不是目标节点，则**判断 p 节点是否为 TreeNode**，如果是则调用红黑树的 putTreeVal 方法 查找目标节点
  走到这代表 p 节点为普通链表节点，则调用普通的链表方法进行查找，并定义变量 binCount 来统计该链表的节点数
  如果 p 的 next 节点为空时，则代表找不到目标节点，则新增一个节点并插入链表尾部，并校验节点数是否超过 8 个，如果超过则调用 treeifyBin 方法（见下文代码块 6）将链表节点转为红黑树节点
  如果遍历的 e 节点存在 hash 值和 key 值都与传入的相同，则 e 节点即为目标节点，跳出循环
  如果 e 节点不为空，则**代表目标节点存在**，使用传入的 value 覆盖该节点的 value，并返回**oldValue**
  如果插入节点后节点数超过阈值，则调用 resize 方法（见下文 resize 方法）进行扩容
