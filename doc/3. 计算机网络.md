
#### osi七层模型、TCP/IP模型

* 应用层    HTTP、SMTP 、telnet、DHCP、PPTP
* 传输层    判断数据包的可靠性，错误重传机制，TCP/UDP协议
    - TCP 协议  基于连接的
* 网络层    路由    ip协议，标识各个网络节点
* 数据链路层  节点到节点数据包的传递,并校验数据包的安全性

![网络模型](../images/网络模型.png)

#### 网络传输
* 不可靠
    - 丢包、重复包
    - 出错
    - 乱序
* 不安全
    - 中间人攻击
    - 窃取
    - 篡改

#### TCP

TCP(Transmission Control Protocol 传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议

    - 在数据正确性与合法性上，TCP用一个校验和函数来检验数据是否有错误，在发送和接收时都要计算校验和;同时可以使用md5认证对数据进行加密。
    - 在保证可靠性上，采用超时重传和捎带确认机制。
    - 在流量控制上，采用滑动窗口协议，协议中规定，对于窗口内未经确认的分组需要重传。
    - 在拥塞控制上，采用TCP拥塞控制算法(也称AIMD算法)。该算法主要包括三个主要部分：1)加性增、乘性减;2)慢启动;3)对超时事件做出反应。


    * TCP 是面向连接的传输层协议
    * 每一条 TCP 连接只能有两个端点(endpoint),每一条 TCP 连接只能是点对点的(一对一)
    * TCP 提供可靠交付的服务
    * TCP 提供全双工通信
    * 面向字节流

* 报头

    ![TCP报文头模型](../images/TCP报文头模型.png)

    我们来分析分析每部分的含义和作用

    * 源端口号/目的端口号: 各占两个字节，端口是传输层与应用层的服务接口
    * 32位序号: 占4字节，连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。
    * 确认序号: 占 4 字节,是期望收到对方的下一个报文段的数据的第一个字节的序号
    * 4位首部长度: 表示该tcp报头有多少个4字节(32个bit)
    * 6位保留:  占 6 位,保留为今后使用,但目前应置为 0
    * 6位标志位：

        URG: 标识紧急指针是否有效 

        ACK: 标识确认序号是否有效 。只有当 ACK=1 时确认号字段才有效.当 ACK=0 时,确认号无效

        PSH: 用来提示接收端应用程序立刻将数据从tcp缓冲区读走 

        RST: 要求重新建立连接. 我们把含有RST标识的报文称为复位报文段 

        SYN: 请求建立连接. 我们把含有SYN标识的报文称为同步报文段 。　同步 SYN = 1 表示这是一个连接请求或连接接受报文

        FIN: 通知对端, 本端即将关闭. 我们把含有FIN标识的报文称为结束报文段。FIN=1 表明此报文段的发送端的数据已发送完毕,并要求释放运输连接

    * 16位窗口大小: 
    * 16位检验和: 由发送端填充, 检验形式有CRC校验等. 如果接收端校验不通过, 则认为数据有问题. 此处的校验和不光包含TCP首部, 也包含TCP数据部分. 
    * 16位紧急指针: 用来标识哪部分数据是紧急数据.
    选项和数据暂时忽略

* 三次握手

    客户端CLOSE状态，服务器LISTEN(监听)状态<br>
    客户端向服务器主动发出连接请求, 服务器被动接受连接请求

    客户端 -- > 服务端 发送SYN包，请求建立连接<br>
    服务端 -- > 客户端 发送SYN+ACK包，确认收到连接请求，并回复响应<br>
    客户端 -- > 服务端 发送ACK包，确认回复，建立连接

    ![TCP三次握手模型](../images/TCP三次握手模型.gif)

    **为什么不用两次?**

        主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

        如果使用的是两次握手建立连接，那么假设：
            客户端发送的第一个请求在网络中滞留较长时间，由于客户端迟迟没有收到服务端的回应，重新发送请求报文，服务器收到后与客户端建立连接，传输数据，然后关闭连接。此时滞留的那一次请求因为网络通畅了，到达了服务器，这个报文本应是失效的，但是两次握手的机制将会让客户端与服务端再次建立连接，导致不必要的错误和资源浪费。

            如果采用的是三次握手，就算失效的报文传送过来，服务端就收到报文并回复了确认报文，但是客户端不会再次发送确认。由于服务端没有收到确认，就知道客户端没有连接。

    **为什么不用四次？**

        因为三次就足够了，四次就多余了。

* 四次挥手

    客户端和服务器都是处于ESTABLISHED状态<br>
    客户端主动断开连接，服务器被动断开连接

    客户端 -- > 服务端 发送FIN=1(连接释放报文)，并且停止发送数据，进入FIN-WAIT-1(终止等待1)状态<br>
    服务端 -- > 客户端 发送确认报文ACK，并带上自己的序列号seq=v，进入了CLOSE-WAIT(关闭等待)状态<br>
    客户端 收到服务器确认，进入 FIN-WAIT-2(终止等待2)状态，等待服务器发送连接释放报文(在这之前还需要接受服务器发送的最终数据)<br>
    服务端 -- > 向客户端发送连接释放报文，FIN=1，确认序号为v+1,服务器就进入了LAST-ACK(最后确认)状态，等待客户端的确认。<br>
    客户端 -- > 服务端 发送ACK包，确认,断开连接<br>
    服务器 收到确认,断开连接

    ![TCP四次挥手模型](../images/TCP四次挥手模型.gif)

    **为什么最后客户端还要等待 2*MSL的时间呢?**

        MSL(Maximum Segment Lifetime)，TCP允许不同的实现可以设置不同的MSL值

        1. 保证客户端发送的最后一个ACK报文能够到达服务器，如果ACK报文丢失，服务器未收到确认，会再次发送，而客户端就能在这个2MSL时间段内收到重传的报文，接着给出回应报文，并且会重启2MSL计时器。

        2. 防止类似与"三次握手"中提到了的"已经失效的连接请求报文段"出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。(简单讲，就是这段时间所有的报文段会慢慢消失，以至于其余的连接请求是不会有正确确认的)

    **为什么建立连接是三次握手，关闭连接确是四次挥手呢？**

        断开连接时，服务器收到对方的FIN包后，仅仅表示对方不在发送数据了，但是还能接收数据。所以己方还可能有数据发送给客户端，因此己方ACK与FIN包会分开发送，从而导致多了一次。

    **如果已经建立了连接, 但是客户端突发故障了怎么办?**

        TCP设有一个保活计时器。
        显然，如果客户端发生故障，服务器不能一直等下去，浪费资源。
        服务器每收到一次客户端的请求都会重置复位这个计时器，时间通常设置为2小时。两小时没有收到客户端请求，会发送一个探测报文段，以后每隔75分钟发送一次，连续10次后，客户端仍没反应，则认为客户端故障，关闭连接。

* 确认应答机制(ACK机制)

    TCP将每个字节的数据都进行了编号, 即为序列号

    ![序列号模型](../images/序列号模型.png)

    每一个ACK都带有对应的确认序列号, 意思是告诉发送者, 我已经收到了哪些数据; 下一次你要从哪里开始发. 

    比如, 客户端向服务器发送了1005字节的数据, 服务器返回给客户端的确认序号是1003, 那么说明服务器只收到了1-1002的数据. 
    1003, 1004, 1005都没收到. 
    此时客户端就会从1003开始重发.

* 超时重传机制

    特定的时间间隔内，发生网络丢包(到客户端的数据包丢失或者客户端确认的ACK包丢失)，主机未收到另一端的确认应答，就会进行重发。

    这种情况下, 主机B会收到很多重复数据. 
    那么TCP协议需要识别出哪些包是重复的, 并且把重复的丢弃. 
    这时候利用前面提到的序列号, 就可以很容易做到去重.

    **超时时间如何确定?**

    TCP为了保证任何环境下都能保持较高性能的通信, 因此会动态计算这个最大超时时间.

* 滑动窗口

* 流量控制

* 拥塞控制

* 延迟应答


