#### 类加载

> https://www.cnblogs.com/ITtangtang/p/3978102.html

Class 文件由类装载器装载后，在 JVM 中将形成一份描述 Class 结构的元信息对象，通过该元信息对象可以获知 Class 的结构信息：如构造函数，属性和方法等，Java 允许用户借由这个 Class 相关的元信息对象间接调用 Class 对象的功能。

虚拟机把描述类的数据从 class 文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。

- 步骤：

  ![类加载模型](../images/类加载模型.png)

  某些情况中，解析阶段可以再初始化阶段之后在开始，这是为了支持 java 语言的运行时绑定(也称为动态绑定或晚期绑定)。

  1.  装载：查找和导入 Class 文件

      - 通过一个类的全限定名来获取定义此类的二进制字节流
      - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
      - 在 java 堆中生成一个代表这个类的 java.lang.Class 对象,作为方法区这些数据的访问入口。

  2.  链接：把类的二进制数据合并到 JRE 中

      (a)校验：检查载入 Class 文件数据的正确性

      (b)准备：给类的静态变量分配存储空间

          准备阶段是正式为类变量分配并设置类变量初始值的阶段，这些内存都将在方法区中进行分配

          这时候进行内存分配的仅包括类变量(被static修饰的变量),而不包括实例变量,实例变量将会在对象实例化时随着对象一起分配在Java堆中;这里所说的初始值“通常情况”是数据类型的零值，假如:

           public static int value = 123;

           value在准备阶段过后的初始值为0而不是123,而把value赋值的putstatic指令将在初始化阶段才会被执行

      (c)解析：将符号引用转成直接引用

  3.  初始化：对类的静态变量，静态代码块执行初始化操作

- 类的初始化

  > https://blog.csdn.net/justloveyou_/article/details/72466105 <br>
 > https://blog.csdn.net/justloveyou_/article/details/72217806 <br>
 > https://blog.csdn.net/justloveyou_/article/details/72466416 <br>

  - 类的实例化是指创建一个类的实例(对象)的过程

  - 类的初始化是指为类中各个类成员(被 static 修饰的成员变量)赋初始值的过程，是类生命周期中的一个阶段。

  对于虚拟机初始化一个类，在虚拟机规范中指明有五种情况需立即对类进行初始化(发生在加载、验证、准备之后):

  1. 遇到 new、getstatic、putstatic 或 invokestatic、这四条字节码(注意：newarray 指令只是数组类型本身的初始化，而不会导致其相关类型的初始化。比如：new String[]只会直接触发 String[]类的初始化，也就是触发对类[Ljava.lang.String 的初始化，而不会导致触发 String 类的初始化)时，如果类没有初始化，则需要先对其初始化。生成这四条指令最常见的 java 代码场景是：

     - 使用 new 关键字实例化对象的时候
     - 读取或设置一个类的静态字段(被 final 修饰，编译器已把结果放入常量池的静态字段除外)的时候
     - 调用一个类的静态方法的时候

  2. 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则进行初始化类

  3. 当初始化一个类时，如果发现其父类还未初始化过，则需要先触发其父类的初始化

  4. 当虚拟机启动时，用户需要指定一个需要运行的主类(包含 main()方法的那个类)，虚拟机会先初始化这个类

  5. 当使用 jdk1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。

  - 注意，对于这五种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这五种场景中的行为称为对一个类进行*主动引用*。除此之外，所有引用类的方式，都不会触发初始化，称为*被动引用*
  - 被动引用的几种经典场景

    > https://github.com/duiliuliu/Interview/tree/master/test/src/com/javaBasic/classInitial

    - 通过子类引用父类的静态字段

      ```
      // PassiveReferenceParent
      public class PassiveReferenceParent {
          static {
              System.out.println("This is static block in the PassiveReferenceParent Class .");
          }
      }

      // PassiveReferenceSon_1
      public class PassiveReferenceSon_1 extends PassiveReferenceParent {
          static {
              System.out.println("This is static block in the PassiveReferenceSon_1 Class .");
          }

          public static String value = "PassiveReferenceSon_1_static_feild value";

          public PassiveReferenceSon_1() {
              System.out.println("PassiveReferenceSon_1 class init!");
          }
      }

      // PassiveReferenceSon_2
      public class PassiveReferenceSon_2 extends PassiveReferenceSon_1 {
          static {
              System.out.println("This is static block in the PassiveReferenceSon_2 Class .");
          }

          public PassiveReferenceSon_2() {
              System.out.println("PassiveReferenceSon_2 class init!");
          }
      }

      public static void main(String[] args) {
          System.out.println(PassiveReferenceSon_2.value);
      }

      // output:
        This is static block in the PassiveReferenceParent Class .
        This is static block in the PassiveReferenceSon_1 Class .
        PassiveReferenceSon_1_static_feild value
      ```

      对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。在本例中，由于 value 字段是在类 PassiveReferenceSon_1 中定义的，因此该类会被初始化；此外，在初始化类 PassiveReferenceSon_1 时，虚拟机会发现其父类 PassiveReferenceParent 还未被初始化，因此虚拟机将先初始化父类 PassiveReferenceParent PassiveReferenceSon_1，而 PassiveReferenceSon_2 始终不会被初始化。

    - 通过数组定义来引用类，不会触发此类的初始化

      ```
      PassiveReferenceSon_1[] passiveReferenceSons_1 = new PassiveReferenceSon_1[10];
      ```

      上述案例运行之后并没有任何输出，说明虚拟机并没有初始化类 PassiveReferenceSon_1[com.javaBasic.classInitial.PassiveReference.PassiveReferenceSon_1 的类的初始化。从类名称我们可以看出，这个类代表了元素类型为 PassiveReferenceSon_1 的一维数组，它是由虚拟机自动生成的，直接继承于 Object 的子类，创建动作由字节码指令 newarray 触发。

    - 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化

      ```
      System.out.println(PassiveReferenceParent.CONSTANT);
      // output:
      hello world
      ```

      述代码运行之后，只输出 “hello world”，这是因为虽然在 Java 源码中引用了 PassiveReferenceParent 类中的常量 CONSTANT，但是编译阶段将此常量的值“hello world”存储到了 NotInitialization 常量池中，对常量 PassiveReferenceParent.CONSTANT 的引用实际都被转化为 NotInitialization 类对自身常量池的引用了。也就是说，实际上 NotInitialization 的 Class 文件之中并没有 PassiveReferenceParent 类的符号引用入口，这两个类在编译为 Class 文件之后就不存在关系了。

- 类的实例化

- 练习

  **java new 一个对象后创建了几个对象**

  **java new 一个 String 对象后，内存中发生了什么**

  **java new 一个对象后，内存中发生了什么**

  **java 创建一个对象有哪几种方法**

#### oom

- 内存溢出 out of memory

程序在申请内存空间时，没有足够的内存空间供其使用，就发生了溢出。如申请一个

- 内存泄漏 memory leak

是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

- OOM 的可能原因?
  - 数据库的 cursor 没有及时关闭
  - 构造 Adapter 没有使用缓存 contentview
  - RegisterReceiver()与 unRegisterReceiver()成对出现
  - 未关闭 InputStream outputStream
  - Bitmap 使用后未调用 recycle()
  - static 等关键字
  - 非静态内部类持有外部类的引用　 context 泄露
