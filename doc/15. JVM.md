
#### 类加载

> https://www.cnblogs.com/ITtangtang/p/3978102.html

Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能。

虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

* 步骤：

    ![类加载模型](../images/类加载模型.png)

    某些情况中，解析阶段可以再初始化阶段之后在开始，这是为了支持java语言的运行时绑定(也称为动态绑定或晚期绑定)。

    1. 装载：查找和导入Class文件

        - 通过一个类的全限定名来获取定义此类的二进制字节流
        - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
        - 在java堆中生成一个代表这个类的java.lang.Class对象,作为方法区这些数据的访问入口。

    2. 链接：把类的二进制数据合并到JRE中

        (a)校验：检查载入Class文件数据的正确性

        (b)准备：给类的静态变量分配存储空间

            准备阶段是正式为类变量分配并设置类变量初始值的阶段，这些内存都将在方法区中进行分配

            这时候进行内存分配的仅包括类变量(被static修饰的变量),而不包括实例变量,实例变量将会在对象实例化时随着对象一起分配在Java堆中;这里所说的初始值“通常情况”是数据类型的零值，假如:

             public static int value = 123;

             value在准备阶段过后的初始值为0而不是123,而把value赋值的putstatic指令将在初始化阶段才会被执行

        (c)解析：将符号引用转成直接引用

    3. 初始化：对类的静态变量，静态代码块执行初始化操作

* 类的初始化

     > https://blog.csdn.net/justloveyou_/article/details/72466105 <br>
    > https://blog.csdn.net/justloveyou_/article/details/72217806 <br>
    > https://blog.csdn.net/justloveyou_/article/details/72466416 <br>

    + 类的实例化是指创建一个类的实例(对象)的过程

    + 类的初始化是指为类中各个类成员(被static修饰的成员变量)赋初始值的过程，是类生命周期中的一个阶段。

    对于虚拟机初始化一个类，在虚拟机规范中指明有五种情况需立即对类进行初始化(发生在加载、验证、准备之后):

    1. 遇到new、getstatic、putstatic或invokestatic、这四条字节码(注意：newarray指令只是数组类型本身的初始化，而不会导致其相关类型的初始化。比如：new String[]只会直接触发String[]类的初始化，也就是触发对类[Ljava.lang.String的初始化，而不会导致触发String类的初始化)时，如果类没有初始化，则需要先对其初始化。生成这四条指令最常见的java代码场景是：

        - 使用new关键字实例化对象的时候
        - 读取或设置一个类的静态字段(被final修饰，编译器已把结果放入常量池的静态字段除外)的时候
        - 调用一个类的静态方法的时候
    
    2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则进行初始化类

    3. 当初始化一个类时，如果发现其父类还未初始化过，则需要先触发其父类的初始化

    4. 当虚拟机启动时，用户需要指定一个需要运行的主类(包含main()方法的那个类)，虚拟机会先初始化这个类

    5. 当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。

    - 注意，对于这五种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这五种场景中的行为称为对一个类进行*主动引用*。除此之外，所有引用类的方式，都不会触发初始化，称为*被动引用*

   

* 类的实例化

* 练习  

    **java new一个对象后创建了几个对象**

    **java new一个String对象后，内存中发生了什么**

    **java new一个对象后，内存中发生了什么**

    **java创建一个对象有哪几种方法**


#### oom

* 内存溢出 out of memory

程序在申请内存空间时，没有足够的内存空间供其使用，就发生了溢出。如申请一个

* 内存泄漏 memory leak

是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

*   OOM的可能原因?
    *   数据库的cursor没有及时关闭
    *   构造Adapter没有使用缓存contentview
    *   RegisterReceiver()与unRegisterReceiver()成对出现
    *   未关闭InputStream outputStream
    *   Bitmap 使用后未调用recycle()
    *   static等关键字
    *   非静态内部类持有外部类的引用　context泄露

