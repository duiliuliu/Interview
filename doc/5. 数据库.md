#### 范式

- 1NF 一个属性不允许在分成多个属性，即每个属性具有 **原子性**
- 2NF **完全函数依赖**，第二范式的目标就是消除函数依赖关系中左边存在的冗余属性。例如，(学号，班级)->姓名，事实上，只需要学号就能决定姓名，因此班级是冗余的，应该去掉。
- 3NF **消除传递依赖** 数据库中的属性依赖仅能依赖于主属性，不存在于其他非主属性的关联。
- BCNF
  - 所有非主属性对每一个码都是完全函数依赖
  - 所有的主属性对于每一个不包含它的码，也是完全函数依赖
  - 没有任何属性完全函数依赖于非码的任意一个组合。
  - R 属于 3NF，不一定属于 BCNF，如果 R 属于 BCNF，一定属于 3NF。
  - 例：配件管理关系模式 WPE(WNO，PNO，ENO，QNT)分别表仓库号，配件号，职工号，数量。有以下条件
    a.一个仓库有多个职工。
    b.一个职工仅在一个仓库工作。
    c.每个仓库里一种型号的配件由专人负责，但一个人可以管理几种配件。
    d.同一种型号的配件可以分放在几个仓库中。

#### 特性

- A atomicity 原子性  
  整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过一样。
- C consistency 一致性
  一个事务可以封装状态改变(除非它是一个只读的)。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。
- I isolation 隔离性
  隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。
- D durability 持久性
  在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

#### 隔离级别

事务的隔离级别有四种，隔离级别高的数据库的可靠性高，但并发量低，而隔离级别低的数据库可靠性低，但并发量高，系统开销小

|                 | 脏读(dirty read) | 不可重复读(unrepeatable read) | 幻读(phantom read) |
| --------------- | ---------------- | ----------------------------- | ------------------ |
| read uncommited | y                | y                             | y                  |
| read commited   | n                | y                             | y                  |
| repearable read | n                | n                             | n                  |
| serialable      | n                | n                             | n                  |

1.  READ UNCOMMITED 未提交读 **更新的瞬间加 行级共享锁**
    事务还没提交，而别的事务可以看到他其中修改的数据的后果，-->脏读(该事物出错而回滚，其他事物已读到改变的值，发生脏读)。
2.  READ COMMITED 提交读 **对被读取的数据加 行级共享锁 读完释放** **更新的瞬间加 行级排他锁**
    其他事务只能看到已经完成的事务的结果，正在执行的，是无法被其他事务看到的。这种级别会出现读取旧数据的现象。大多数数据库系统的默认隔离级别是 READ COMMITTED
    也容易发生丢失更新： 如果 A、B 同时获取资源 X，然后事务 A 先发起更新记录 X，那么事务 B 将等待事务 A 完成，然后获得记录 X 的排他锁，进行更改，这样事务 A 的更新就会丢失。

    |                           |     |                                          |
    | ------------------------- | --- | ---------------------------------------- |
    | 事务 A                    | --- | 事务 B                                   |
    | 读取 X=100(同时上共享锁)  | --- | 读取 X=100(同时上共享锁)                 |
    | 读取成功(释放共享锁)      | --- | 读取成功(释放共享锁)                     |
    | UPDATE X=X+100 (上排他锁) | --- |                                          |
    |                           | --- | UPDATING A(等待事务 A 释放对 X 的排他锁) |
    | 事务成功(释放排他锁)X=200 | --- |                                          |
    |                           | --- | UPDATE X=X+200(成功上排他锁)             |
    | (事务 A 的更新丢失)       | --- | 事务成功(释放排他锁)X=300<br>            |

3.  REPEATBLE COMMITED 可重复读 **对被读取的数据加 行级共享锁 事务结束释放** **更新的瞬间加 行级排他锁**
    事务结束才释放行级共享锁 ，这样保证了可重复读(既是其他的事务职能读取该数据，但是不能更新该数据)。　会导致幻读
4.  SERIALIZABLE 可串行化
    SERIALIZABLE 是最高的隔离级别，它通过强制事务串行执行(注意是串行)，避免了前面的幻读情况，由于他大量加上锁(加表锁)，导致大量的请求超时，因此性能会比较底下，再特别需要数据一致性且并发量不需要那么大的时候才可能考虑这个隔离级别

- 期间造的问题
  - 丢失更新
  - 脏读(未提交读)
  - 不可重复读 一个事务在自己没有更新数据库数据的情况，同一个查询操作执行两次或多次的结果应该是一致的;如果不一致，就说明为不可重复读。
  - 幻读 事务 A 读的时候读出了 15 条记录，事务 B 在事务 A 执行的过程中 增加 了 1 条，事务 A 再读的时候就变成了 16 条，这种情况就叫做幻影读。

#### 锁机制

- 共享锁 (S 锁)
  由读表操作加上的锁，加锁后其他用户只能获取该表或行的共享锁，不能获取排它锁，也就是说只能读不能写
- 排它锁 (X 锁)
  由写表操作加上的锁，加锁后其他用户不能获取该表或行的任何锁，典型是 mysql 事务</br>

根据锁的范围，可以分为

- 表锁
  给整张表加锁
- 行锁
  给行数据加锁

因此锁可以分为表级共享锁、行级共享锁、表级排它锁、行级排它锁。

#### 存储过程

对于我们常用的关系型数据库，操作数据库的语言一般是 SQL，SQL 在执行的时候需要先编译,然后执行.

而存储过程(Stored Procedure)是一组为了完成某种特定功能的*SQL 语句集*,经编译后存储在数据库中,用户通过存储过程的名字并给定参数(如果需要参数)来调用执行它。

- 创建存储过程

  ```
  create procedure sp_name
  @[参数名] [类型],@[参数名] [类型]
  as
  begin
  .........
  end
  以上格式还可以简写成：
  create proc sp_name
  @[参数名] [类型],@[参数名] [类型]
  as
  begin
  .........
  end
  /*注：“sp_name”为需要创建的存储过程的名字，该名字不可以以阿拉伯数字开头*/
  ```

- 调用存储过程

  基本语法：exec sp_name [参数名]

- 删除存储过程

  1.基本语法：
  drop procedure sp_name

  2.注意事项
  (1)不能在一个存储过程中删除另一个存储过程，只能调用另一个存储过程

- 其他常用命令

  1.show procedure status
  显示数据库中所有存储的存储过程基本信息，包括所属数据库，存储过程名称，创建时间等

  2.show create procedure sp_name
  显示某一个 mysql 存储过程的详细信息

  3、exec sp_helptext sp_name
  显示你这个 sp_name 这个对象创建文本

#### 索引

索引(index)是帮助数据库高效获取数据的数据结构。

在数据之外，数据库系统维护着满足特定查找算法的数据结构,这些数据结构以某种方式引用(指向)数据,可以在这些数据结构上实现高级查找算法，提高查询速度，这种数据结构，就是索引。

- 索引存储分类(MySql)

  - B-Tree 索引 最常见的索引类型，大部分引擎都支持 B 树索引。
  - Hash 索引
  - R-tree 索引(空间索引) 空间索引是 MyISAM 的一种特殊索引类型，主要用于地理空间数据类型。
  - Full-text(全文索引) 全文索引也是 MyISAM 的一种特殊索引类型，主要用于全文索引，InnoDB 从 MySQL5.6 版本提供对全文索引的支持。

- B-tree 索引类型

  - 普通索引

    最基本的索引类型，而且它没有唯一性之类的限制，可以通过以下几种方式创建：

    ```
    //创建索引
    create index index_name on table_name(col1,col2...)

    //修改表
    alter table_name add index index_name (col1,col2...)

    //创建表时指定索引
    create table table_name([...],index index_name (col1,col2...))
    ```

  - UNIQUE 索引

    唯一索引

    ```
    关键字为 UNIQUE INDEX

    //创建索引
    create UNIQUE INDEX index_name on table_name(col1,col2...)

    //修改表
    alter table_name add UNIQUE INDEX index_name (col1,col2...)

    //创建表时指定索引
    create table table_name([...],UNIQUE INDEX index_name (col1,col2...))
    ```

  - 主键索引

    主键是一种唯一性索引，但它必须指定为“PRIMARY KEY”,不允许 null

    ```
    // 1. 创建表时指定
    CREATE TABLE 表名( […], PRIMARY KEY (列的列表) );
    // 2. 修改表时加入
    ALTER TABLE 表名 ADD PRIMARY KEY (列的列表);
    ```

- 删除索引

  ```
  DROP INDEX index_name ON talbe_name

  ALTER TABLE table_name DROP INDEX index_name

  ALTER TABLE table_name DROP PRIMARY KEY
  ```

- 查看索引

  ```
  mysql> show index from table_name;
  ```

- 设置索引的规则

  1. 较频繁的作为查询条件的字段
  2. 唯一性太差的字段不适合单独做索引，即使频繁作为查询条件
  3. 更新非常频繁的字段不适合作为索引

- 索引的弊端

  索引是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL 在运行时也要消耗资源维护索引，因此索引并不是越多越好。

- 处理重复记录的常用操作

  ```
  // 查找重复记录
  select * from table_name where column_name in (select column in table_name group by column having count(column) > 1)

  // 删除重复记录
  delete ...

  // 查找多个字段重复记录
  select * from table_name where column_name in (select column_1,column_2 in table_name group by column_1 column_2 having count(*) > 1)
  ```

#### SQL

- 数据定义：Create Table,Alter Table,Drop Table, Craete/Drop Index
- 数据操纵：Select ,insert,update,delete
- 数据控制：grant,revoke

- 内连接/外连接

  - 内连接是保证两个表中的数据要满足连接条件

---

> https://blog.csdn.net/gui951753/article/details/79489279
