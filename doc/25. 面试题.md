#### 海量数据排序

> https://blog.csdn.net/yusiguyuan/article/details/12903975
 > https://blog.csdn.net/v_JULY_v/article/details/6279498

1. 分而治之/Hash 映射 堆/快速/归并排序

   - 一个 10g 的关键词 log，找出词频最高的前 k 个词，设可用内存为 2g

     难点分析：

     1. 如何在有限的内存中对大量数据进行词频统计
     2. 如何在有限的内存中找出前 k 个高频词

     词频统计：我们自然的会想到 hash，然而数据太多内存不足，所以我们需要将数据分段，然后将每段的结果进行汇总计算即可。

     分段：

     1. 普通分段
     2. hash 计算，按照范围分段(因为是词频统计，尽可能将同样的词划分到一段中，让最后的计算只需要词频排序即可。避免最后还需要对不同分段的同一个词进行词频汇总)

     汇总：汇总所有分段结果进行排序。

     1. 一般汇总，
     2. 缓冲区，汇总部分

     排序：

     对于排序算法的选择，如果一次性将结果汇总，快排/归并/堆排序同样的时间复杂度。
     倘若是按照缓冲区一段段的读取数据进行汇总，此时选用堆排序性能更优。堆排序中，堆的构建需要 o(n)，而堆与堆的调整只需要 lgn，在第一次堆排序需要调整 n-1 次，复杂度为 o(nlogn),但是在之后的调整与读取数据中只需要 lgn 的时间。

2. 多层桶划分
3. bitmap
4. Trie 树/数据库/倒排索引
5. 外部排序
6. 分布式处理之 Map reduce

#### 浏览器中输入 www.taobao.com 发生了什么

#### LRU 算法实现

LRU 全称是 Least Recently Used，即最近最久未使用的意思。

LRU 算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。

1.  数组+时间计数
    每访问一次数据，相应的时间计数归零，其他数据时间计数加一，当数组空间已满时，将时间计数最大的数据项淘汰。
2.  链表实现
    每次插入新的数据都选择从头部插入，如果数据已存在，则将数据移到头部；那么当链表满的时候，就将链表尾部的数据丢弃。
3.  链表和 hashmap
    当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。(LinkedHashMap)

#### 设计一个秒杀系统

1. 前端层面，必须提到浏览器缓存、尽可能减少请求数量、使用延迟加载（ajax 技术）、使用 cdn 缓存、压缩静态文件等；

2. web 服务器层面，必须提到开启 gzip 压缩技术、卸载 web 服务器不必要的模块、开启服务器缓存等；

3. PHP 语言层面，开启编译缓存、使用 PHP 扩展实现计算密集型模块、使用 HHVM 或 PHP7 替代旧版本 PHP、修改 php.ini 参数对 PHP 性能调优、减少高消耗函数使用等；

4. 数据库 MySQL 层面，合理创建索引、合理设计数据表结构、尽可能减少数据库连接、对数据库内常用数据进行缓存、读写分离、垂直（水平）分库分表等；

5. 非关系型数据库，使用非关系数据库减少数据库链接、保持数据库与非关系数据库数据一致性等
