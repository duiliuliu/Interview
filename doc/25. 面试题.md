#### 海量数据排序

> https://blog.csdn.net/yusiguyuan/article/details/12903975
 > https://blog.csdn.net/v_JULY_v/article/details/6279498

1. 分而治之/Hash 映射 堆/快速/归并排序

   - 一个 10g 的关键词 log，找出词频最高的前 k 个词，设可用内存为 2g

     难点分析：

     1. 如何在有限的内存中对大量数据进行词频统计
     2. 如何在有限的内存中找出前 k 个高频词

     词频统计：我们自然的会想到 hash，然而数据太多内存不足，所以我们需要将数据分段，然后将每段的结果进行汇总计算即可。

     分段：

     1. 普通分段
     2. hash 计算，按照范围分段(因为是词频统计，尽可能将同样的词划分到一段中，让最后的计算只需要词频排序即可。避免最后还需要对不同分段的同一个词进行词频汇总)

     汇总：汇总所有分段结果进行排序。

     1. 一般汇总，
     2. 缓冲区，汇总部分

     排序：

     对于排序算法的选择，如果一次性将结果汇总，快排/归并/堆排序同样的时间复杂度。
     倘若是按照缓冲区一段段的读取数据进行汇总，此时选用堆排序性能更优。堆排序中，堆的构建需要 o(n)，而堆与堆的调整只需要 lgn，在第一次堆排序需要调整 n-1 次，复杂度为 o(nlogn),但是在之后的调整与读取数据中只需要 lgn 的时间。

2. 多层桶划分
3. bitmap
4. Trie 树/数据库/倒排索引
5. 外部排序
6. 分布式处理之 Map reduce

#### 浏览器中输入 www.taobao.com 发生了什么

#### 对于缓存有什么思考

缓存是对读取数据速度的提升，将常用/高频的数据存放与缓存中，可以在下一次的数据访问中提升效率。

对于缓存，很多地方都有遇到，有磁盘缓存，DB 缓存，浏览器缓存，CPU 一级/二级缓存等。

- 简单的 Java 缓存队列
  在 Java 程序中，对于缓存可以用 LRU 队列进行实现，将最新访问的数据作为头节点，而最久未使用的数据存放队尾，在队列长度达到限制后，扔掉队尾的数据。可以运用 LinkedHashMap 来实现 LRU 队列，因为 LInkedHashMap 有两个指针域分别指向前驱与后缀，保证了队列顺序，而且采用 hash 散列存储，访问效率较高。构造时构造一个空的 linkedhashmap。get 时传入 key，类似与 hashmap，将 key 的 hashcode 二次 hash 后与长度-1 进行&运算，快速得到位置下标，获取数据，并修改数据指针域，将其插入头节点。set 方法通过 hash 得出位置后，存储数据然后后缀指针域指向头节点。

- LRU 算法实现

  LRU 全称是 Least Recently Used，即最近最久未使用的意思。

  LRU 算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。

  1.  数组+时间计数
      每访问一次数据，相应的时间计数归零，其他数据时间计数加一，当数组空间已满时，将时间计数最大的数据项淘汰。
  2.  链表实现
      每次插入新的数据都选择从头部插入，如果数据已存在，则将数据移到头部；那么当链表满的时候，就将链表尾部的数据丢弃。
  3.  链表和 hashmap
      当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。(LinkedHashMap)

- DB 缓存

  关键点：

  - 如何与 DB 保持同步
  - 缓存过期时间
  - 存储结构
  - 缓存异常捕获
  - 超时设置

**Spring 缓存**
**分布式缓存**

- redis 缓存设计

> https://blog.csdn.net/zjttlance/article/details/80234341?utm_source=blogxgwz3

> https://blog.csdn.net/tangkund3218/article/details/50915007?utm_source=blogxgwz8

- 注意问题
  > https://blog.csdn.net/wuxing26jiayou/article/details/79544410?utm_source=blogxgwz0
  - 缓存穿透
  - 缓存雪崩
  - 缓存击穿

#### 设计一个秒杀系统

1. 前端层面，必须提到浏览器缓存、尽可能减少请求数量、使用延迟加载（ajax 技术）、使用 cdn 缓存、压缩静态文件等；

2. web 服务器层面，必须提到开启 gzip 压缩技术、卸载 web 服务器不必要的模块、开启服务器缓存等；

3. PHP 语言层面，开启编译缓存、使用 PHP 扩展实现计算密集型模块、使用 HHVM 或 PHP7 替代旧版本 PHP、修改 php.ini 参数对 PHP 性能调优、减少高消耗函数使用等；

4. 数据库 MySQL 层面，合理创建索引、合理设计数据表结构、尽可能减少数据库连接、对数据库内常用数据进行缓存、读写分离、垂直（水平）分库分表等；

5. 非关系型数据库，使用非关系数据库减少数据库链接、保持数据库与非关系数据库数据一致性等
